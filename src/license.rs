use crate::error::AppError;
use sha2::{Sha256, Digest};
use std::time::{SystemTime, UNIX_EPOCH};

/// License validation module to prevent unauthorized use of sol_beast
/// 
/// This module implements a license key verification system that:
/// 1. Validates the format and authenticity of license keys
/// 2. Prevents code copying and unauthorized distribution
/// 3. Ensures only licensed users can run the bot
///
/// License keys are generated by the developer and tied to specific
/// deployment instances.

const LICENSE_SALT: &[u8] = b"sol_beast_v1_2025_license_validation";
const MIN_LICENSE_LENGTH: usize = 32;

/// Validate a license key
/// 
/// License key format: Base58-encoded hash derived from:
/// - Project identifier
/// - Client identifier (optional)
/// - Timestamp range (optional for time-limited licenses)
/// - Secret salt (known only to developer)
///
/// Returns Ok(()) if valid, Err with detailed message if invalid
pub fn validate_license_key(license_key: &str) -> Result<(), AppError> {
    // Basic format validation
    if license_key.len() < MIN_LICENSE_LENGTH {
        return Err(AppError::Validation(format!(
            "Invalid license key: too short (minimum {} characters required)",
            MIN_LICENSE_LENGTH
        )));
    }

    // Decode base58 license key
    let decoded = bs58::decode(license_key)
        .into_vec()
        .map_err(|_| AppError::Validation("Invalid license key: not valid Base58 encoding".to_string()))?;

    if decoded.is_empty() {
        return Err(AppError::Validation("Invalid license key: empty after decoding".to_string()));
    }

    // Verify license structure
    // Format: [version(1)][type(1)][timestamp(8)][hash(32)][checksum(4)]
    if decoded.len() < 46 {
        return Err(AppError::Validation(
            "Invalid license key: incorrect structure".to_string()
        ));
    }

    let version = decoded[0];
    let license_type = decoded[1];
    
    // Check version
    if version != 1 {
        return Err(AppError::Validation(format!(
            "Unsupported license key version: {}. Please update sol_beast or contact developer for new license.",
            version
        )));
    }

    // Validate license type
    match license_type {
        1 => {
            // Type 1: Standard perpetual license
            log::info!("License validated: Standard perpetual license");
        }
        2 => {
            // Type 2: Time-limited license
            let timestamp_bytes: [u8; 8] = decoded[2..10].try_into()
                .map_err(|_| AppError::Validation("Invalid license key: corrupted timestamp".to_string()))?;
            let expiry_timestamp = u64::from_be_bytes(timestamp_bytes);
            let current_timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();
            
            if current_timestamp > expiry_timestamp {
                return Err(AppError::Validation(
                    "License key expired. Please contact the developer to renew your license.".to_string()
                ));
            }
            
            let days_remaining = (expiry_timestamp - current_timestamp) / 86400;
            log::info!("License validated: Time-limited license ({} days remaining)", days_remaining);
            
            if days_remaining < 7 {
                log::warn!("⚠️  License expires in {} days. Please renew soon to avoid interruption.", days_remaining);
            }
        }
        _ => {
            return Err(AppError::Validation(format!(
                "Unknown license type: {}. Please contact developer.",
                license_type
            )));
        }
    }

    // Verify checksum
    let data_end = decoded.len() - 4;
    let data = &decoded[..data_end];
    let stored_checksum = &decoded[data_end..];
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.update(LICENSE_SALT);
    let computed_hash = hasher.finalize();
    let computed_checksum = &computed_hash[..4];
    
    if stored_checksum != computed_checksum {
        return Err(AppError::Validation(
            "Invalid license key: checksum verification failed. License may be corrupted or tampered.".to_string()
        ));
    }

    log::info!("✓ License key validated successfully");
    Ok(())
}

/// Generate a machine fingerprint for hardware-locked licenses (future enhancement)
#[allow(dead_code)]
fn get_machine_fingerprint() -> String {
    use sha2::{Sha256, Digest};
    
    let mut hasher = Sha256::new();
    
    // Add system-specific identifiers
    if let Ok(hostname) = std::env::var("HOSTNAME") {
        hasher.update(hostname.as_bytes());
    }
    
    // Add user identifier
    if let Ok(user) = std::env::var("USER") {
        hasher.update(user.as_bytes());
    }
    
    let result = hasher.finalize();
    bs58::encode(result).into_string()
}

/// Display license information at startup
pub fn display_license_info() {
    log::info!("╔═══════════════════════════════════════════════════════════════╗");
    log::info!("║                        sol_beast v0.1.0                       ║");
    log::info!("║                 Licensed Software - All Rights Reserved       ║");
    log::info!("╚═══════════════════════════════════════════════════════════════╝");
    log::info!("");
    log::info!("This software is protected by license agreement.");
    log::info!("Unauthorized copying, modification, or distribution is prohibited.");
    log::info!("For licensing inquiries, contact the developer.");
    log::info!("");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_invalid_short_key() {
        let result = validate_license_key("tooshort");
        assert!(result.is_err());
    }

    #[test]
    fn test_invalid_base58() {
        // Characters not in base58 alphabet (0, O, I, l are excluded)
        let result = validate_license_key("0OIl0OIl0OIl0OIl0OIl0OIl0OIl0OIl0OIl0OIl");
        assert!(result.is_err());
    }

    #[test]
    fn test_empty_key() {
        let result = validate_license_key("");
        assert!(result.is_err());
    }
}
